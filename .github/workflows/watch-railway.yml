name: watch-railway

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

jobs:
  watch-and-act:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    env:
      RW_PROJECT_ID: ${{ secrets.RW_PROJECT_ID }}
      RW_ENV_ID: ${{ secrets.RW_ENV_ID }}
      RW_SERVICE_ID: ${{ secrets.RW_SERVICE_ID }}
      RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      META_ACCESS_TOKEN: ${{ secrets.META_ACCESS_TOKEN }}
      WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
      OPS_ALERT_PHONE: ${{ secrets.OPS_ALERT_PHONE }}
      POST_DEPLOY_URL: ${{ secrets.POST_DEPLOY_URL }}

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI and tools
        run: |
          npm i -g @railway/cli
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      # 1) LOG PROFUNDO — captura stack mesmo quando o Railway só mostra "stopping container"
      - name: Fetch logs (deep)
        run: |
          export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
          railway logs --project "${RW_PROJECT_ID}" --environment "${RW_ENV_ID}" --service "${RW_SERVICE_ID}" -n 2000 --timestamps > logs.txt || true
          echo "---- tail (120) ----"
          tail -n 120 logs.txt || true

      # 2) HEALTH-CHECK — prova de vida da app publicada
      - name: Health probe
        id: health
        run: |
          CODE=$(curl -s -o /dev/null -w "%{http_code}" "${POST_DEPLOY_URL}/health" || echo "000")
          echo "code=$CODE" >> "$GITHUB_OUTPUT"

      # 3) CLASSIFICAÇÃO — IndentationError / PythonError / Crash (sem stack)
            - name: Detect errors
        id: detect
        run: |
          python - <<'PY'
          import re, json

          def strip_ansi(s: str) -> str:
              return re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', s)

          txt = open("logs.txt","r",errors="ignore").read()
          txt = strip_ansi(txt)

          # 1) Se houver "IndentationError", capturar o bloco mais recente e o respectivo "File ... line ..."
          kind, file, line, summary = "", "", "0", ""
          if "IndentationError" in txt:
              # pega a ÚLTIMA ocorrência (a mais recente)
              ind_pos = txt.rfind("IndentationError")
              # procura o "File "...", line N" MAIS PRÓXIMO ANTES
              pre = txt[:ind_pos]
              mfile = None
              for m in re.finditer(r'File "([^"]+)", line (\d+)', pre):
                  mfile = m  # fica com o último
              if mfile:
                  file = mfile.group(1)
                  line = mfile.group(2)
                  kind = "IndentationError"
                  # resumo curto (linha inteira do erro)
                  summary = txt[ind_pos: txt.find("\n", ind_pos)]
          else:
              # 2) Qualquer outro PythonError com arquivo/linha
              m2 = re.search(r'File "([^"]+)", line (\d+)[\s\S]+?\n([A-Za-z_]+Error:[^\n]+)', txt)
              if m2:
                  file = m2.group(1); line = m2.group(2)
                  kind = "PythonError"
                  summary = m2.group(3)

              # 3) Sem stack, mas container parando
              elif "stopping container" in txt.lower() or "exited with code" in txt.lower():
                  kind = "Crash"
                  summary = "Container stopped/crashed — no traceback in logs"

          # Normalizar caminho: remover prefixo /app/ se existir
          if file.startswith("/app/"):
              file = file[len("/app/"):]

          out = {"kind":kind, "file":file, "line":line, "summary":summary}
          open("detect.json","w").write(json.dumps(out))
          PY
          echo "kind=$(jq -r .kind detect.json)" >> "$GITHUB_OUTPUT"
          echo "file=$(jq -r .file detect.json)" >> "$GITHUB_OUTPUT"
          echo "line=$(jq -r .line detect.json)" >> "$GITHUB_OUTPUT"
          echo "summary=$(jq -r .summary detect.json)" >> "$GITHUB_OUTPUT"
          
      # 4) INCIDENTE — abre Issue se houver erro OU se o health != 200
      - name: Open incident (if any)
        if: ${{ steps.detect.outputs.kind != '' || steps.health.outputs.code != '200' }}
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "Auto-incident: ${{ steps.detect.outputs.kind != '' && steps.detect.outputs.kind || 'Health ' }} (code=${{ steps.health.outputs.code }}) ${{ steps.detect.outputs.file != '' && format('in {0}:{1}', steps.detect.outputs.file, steps.detect.outputs.line) || '' }}"
          content-file: logs.txt
          labels: |
            auto/incident
            runtime

      # 5) PR AUTOMÁTICO — só para IndentationError (correção trivial, segura)
      - name: Try autofix (indentation only)
        if: ${{ steps.detect.outputs.kind == 'IndentationError' }}
        run: |
          if [ -f scripts/autofix/indent_fix.py ]; then
            python scripts/autofix/indent_fix.py "${{ steps.detect.outputs.file }}" "${{ steps.detect.outputs.line }}"
            git config user.name "ops-bot"
            git config user.email "ops-bot@users.noreply.github.com"
            git checkout -b "autofix/indent-${{ steps.detect.outputs.file }}-${{ steps.detect.outputs.line }}" || git checkout "autofix/indent-${{ steps.detect.outputs.file }}-${{ steps.detect.outputs.line }}"
            git add -A
            git commit -m "autofix: normalize indentation on ${{ steps.detect.outputs.file }}:${{ steps.detect.outputs.line }}" || echo "No changes to commit"
            git push -u origin HEAD
          else
            echo "indent_fix.py not found; skipping."
          fi

      - name: Open PR for autofix
        if: ${{ steps.detect.outputs.kind == 'IndentationError' }}
        uses: peter-evans/create-pull-request@v6
        with:
          base: main
          branch: "autofix/indent-${{ steps.detect.outputs.file }}-${{ steps.detect.outputs.line }}"
          title: "Autofix: Indentation in ${{ steps.detect.outputs.file }}:${{ steps.detect.outputs.line }}"
          body: "Correção automática de indentação detectada no runtime (Railway)."
          labels: autofix/indentation

      # 6) RESUMO NO WHATSAPP — incluindo o status do health
      - name: WhatsApp ping (summary)
        if: ${{ env.META_ACCESS_TOKEN != '' && env.WHATSAPP_PHONE_NUMBER_ID != '' && env.OPS_ALERT_PHONE != '' }}
        env:
          KIND: ${{ steps.detect.outputs.kind }}
          FILE: ${{ steps.detect.outputs.file }}
          LINE: ${{ steps.detect.outputs.line }}
          HCODE: ${{ steps.health.outputs.code }}
        run: |
          MSG="Ops Watcher: kind=${KIND:-none} file=${FILE:-n/a} line=${LINE:-0} health=${HCODE:-000}"
          curl -s -X POST "https://graph.facebook.com/v21.0/${WHATSAPP_PHONE_NUMBER_ID}/messages" \
            -H "Authorization: Bearer ${META_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"messaging_product\":\"whatsapp\",\"to\":\"${OPS_ALERT_PHONE}\",\"type\":\"text\",\"text\":{\"preview_url\":false,\"body\":\"${MSG}\"}}" \
            >/dev/null 2>&1 || true
