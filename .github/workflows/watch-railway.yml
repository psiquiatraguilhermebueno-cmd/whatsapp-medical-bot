name: watch-railway

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

jobs:
  watch-and-act:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    env:
      RW_PROJECT_ID: ${{ secrets.RW_PROJECT_ID }}
      RW_ENV_ID: ${{ secrets.RW_ENV_ID }}
      RW_SERVICE_ID: ${{ secrets.RW_SERVICE_ID }}
      # Use apenas o Project Token aqui
      RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      META_ACCESS_TOKEN: ${{ secrets.META_ACCESS_TOKEN }}
      WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
      OPS_ALERT_PHONE: ${{ secrets.OPS_ALERT_PHONE }}
      POST_DEPLOY_URL: ${{ secrets.POST_DEPLOY_URL }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          npm i -g @railway/cli
          sudo apt-get update -y
          sudo apt-get install -y jq curl
          railway --version || true

      - name: Fetch logs deep (Project Token + flags explícitas)
        run: |
          set -e
          # flags evitam 'link' e qualquer login interativo
          railway logs \
            --project "${RW_PROJECT_ID}" \
            --environment "${RW_ENV_ID}" \
            --service "${RW_SERVICE_ID}" > logs.txt 2>&1 || true
          echo "---- tail (200) ----"
          tail -n 200 logs.txt || true
          echo "---- size(bytes) ----"
          wc -c logs.txt || true

      - name: Health probe
        id: health
        run: |
          CODE=$(curl -s -o /dev/null -w "%{http_code}" "${POST_DEPLOY_URL}/health" || echo "000")
          echo "code=$CODE" >> "$GITHUB_OUTPUT"

      - name: Detect errors
        id: detect
        run: |
          python - <<'PY'
          import re, json
          with open("logs.txt","r",errors="ignore") as f:
              raw=f.read()
          txt = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', raw)

          kind=""; file=""; line="0"; summary=""

          mA = re.search(r'File "(/app/src/main\.py)", line (\d+)', txt)
          if mA and "IndentationError" in txt:
              file, line = mA.group(1), mA.group(2)
              kind, summary = "IndentationError", "IndentationError (stack match)"

          if not kind:
              mB = re.search(r'Failed to load main\.app:\s*IndentationError:[^\(]*\(([^,]+), line (\d+)\)', txt)
              if mB:
                  fname = mB.group(1).strip()
                  line  = mB.group(2).strip()
                  file = "src/main.py" if fname.endswith("main.py") else (f"src/{fname}" if not fname.startswith("src/") else fname)
                  kind, summary = "IndentationError", "IndentationError (boot match)"

          if not kind and "IndentationError" in txt:
              ind_pos = txt.rfind("IndentationError")
              pre = txt[:ind_pos]
              mfile = None
              for m in re.finditer(r'File "([^"]+)", line (\d+)', pre):
                  mfile = m
              if mfile:
                  file, line = mfile.group(1), mfile.group(2)
                  kind, summary = "IndentationError", "IndentationError (generic match)"

          if not kind:
              m2 = re.search(r'File "([^"]+)", line (\d+)[\s\S]+?\n([A-Za-z_]+Error:[^\n]+)', txt)
              if m2:
                  file, line = m2.group(1), m2.group(2)
                  kind, summary = "PythonError", m2.group(3)

          if not kind and ("stopping container" in txt.lower() or "exited with code" in txt.lower()):
              kind, summary = "Crash", "Container stopped/crashed"

          if file.startswith("/app/"):
              file = file[len("/app/"):]
          out={"kind":kind,"file":file,"line":line,"summary":summary}
          open("detect.json","w").write(json.dumps(out))
          PY
          echo "kind=$(jq -r .kind detect.json)" >> "$GITHUB_OUTPUT"
          echo "file=$(jq -r .file detect.json)" >> "$GITHUB_OUTPUT"
          echo "line=$(jq -r .line detect.json)" >> "$GITHUB_OUTPUT"
          echo "summary=$(jq -r .summary detect.json)" >> "$GITHUB_OUTPUT"

      - name: Open error incident
        if: ${{ steps.detect.outputs.kind != '' }}
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "Auto-incident: ${{ steps.detect.outputs.kind }} in ${{ steps.detect.outputs.file }}:${{ steps.detect.outputs.line }}"
          content-file: logs.txt
          labels: |
            auto/incident
            runtime

      - name: Open health incident
        if: ${{ steps.detect.outputs.kind == '' && steps.health.outputs.code != '200' }}
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "Auto-incident: Health (code=${{ steps.health.outputs.code }})"
          content-file: logs.txt
          labels: |
            auto/incident
            runtime

      - name: Ensure indent_fix.py (only for IndentationError)
        if: ${{ steps.detect.outputs.kind == 'IndentationError' }}
        run: |
          mkdir -p scripts/autofix
          cat > scripts/autofix/indent_fix.py <<'PY'
          #!/usr/bin/env python3
          import sys, pathlib
          if len(sys.argv) < 2:
              sys.exit(2)
          p = pathlib.Path(sys.argv[1])
          line_no = int(sys.argv[2]) if len(sys.argv) > 2 else None
          lines = p.read_text(encoding="utf-8", errors="ignore").splitlines()
          if not lines: sys.exit(0)
          def ind(s): return len(s) - len(s.lstrip(" "))
          def is_code(line):
              t = line.strip()
              return t != "" and not t.startswith("#")
          targets = []
          if line_no:
              targets = [max(1, min(len(lines), line_no))]
          else:
              for i, s in enumerate(lines, start=1):
                  if s.lstrip().startswith("return ") and (i == 1 or ind(s) % 4 != 0):
                      targets = [i]; break
          for ln in targets:
              idx = ln - 1
              block_idx = idx - 1
              while block_idx >= 0:
                  s = lines[block_idx].rstrip()
                  if is_code(s) and s.endswith(":"):
                      break
                  block_idx -= 1
              target_indent = ind(lines[block_idx]) + 4 if block_idx >= 0 else 0
              lines[idx] = (" " * target_indent) + lines[idx].lstrip(" ")
          p.write_text("\n".join(lines) + ("\n" if not lines[-1].endswith("\n") else ""), encoding="utf-8")
          print(f"fixed {p} at lines {targets}")
          PY
          chmod +x scripts/autofix/indent_fix.py

      - name: Try autofix indentation
        id: autofix
        if: ${{ steps.detect.outputs.kind == 'IndentationError' }}
        env:
          DETECT_FILE: ${{ steps.detect.outputs.file }}
          DETECT_LINE: ${{ steps.detect.outputs.line }}
        run: |
          set -e
          SANITIZED_FILE="$(echo "$DETECT_FILE" | tr '/ ' '--')"
          BRANCH="autofix/indent-${SANITIZED_FILE}-${DETECT_LINE}"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
          python scripts/autofix/indent_fix.py "$DETECT_FILE" "$DETECT_LINE" || true
          git config user.name "ops-bot"
          git config user.email "ops-bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          git add -A
          git commit -m "autofix: normalize indentation on ${DETECT_FILE}:${DETECT_LINE}" || echo "No changes to commit"
          git push -u origin HEAD || true

      - name: Open PR
        if: ${{ steps.detect.outputs.kind == 'IndentationError' }}
        uses: peter-evans/create-pull-request@v6
        with:
          base: "main"
          branch: "${{ steps.autofix.outputs.branch_name }}"
          title: "Autofix: Indentation in ${{ steps.detect.outputs.file }}:${{ steps.detect.outputs.line }}"
          body: "Correção automática de indentação detectada no runtime (Railway)."
          labels: autofix/indentation

      - name: WhatsApp ping
        if: ${{ env.META_ACCESS_TOKEN != '' && env.WHATSAPP_PHONE_NUMBER_ID != '' && env.OPS_ALERT_PHONE != '' }}
        env:
          KIND: ${{ steps.detect.outputs.kind }}
          FILE: ${{ steps.detect.outputs.file }}
          LINE: ${{ steps.detect.outputs.line }}
          HCODE: ${{ steps.health.outputs.code }}
        run: |
          MSG="Ops Watcher: kind=${KIND:-none} file=${FILE:-n/a} line=${LINE:-0} health=${HCODE:-000}"
          curl -s -X POST "https://graph.facebook.com/v21.0/${WHATSAPP_PHONE_NUMBER_ID}/messages" \
            -H "Authorization: Bearer ${META_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"messaging_product\":\"whatsapp\",\"to\":\"${OPS_ALERT_PHONE}\",\"type\":\"text\",\"text\":{\"preview_url\":false,\"body\":\"${MSG}\"}}" \
            >/dev/null 2>&1 || true
