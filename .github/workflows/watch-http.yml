name: watch-http

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

jobs:
  probe-and-autofix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    env:
      POST_DEPLOY_URL: ${{ secrets.POST_DEPLOY_URL }}
      META_ACCESS_TOKEN: ${{ secrets.META_ACCESS_TOKEN }}
      WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
      OPS_ALERT_PHONE: ${{ secrets.OPS_ALERT_PHONE }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Probe boot-state
        id: probe
        run: |
          set -e
          URL="${POST_DEPLOY_URL}/ops/boot-state"
          echo "GET $URL"
          CODE=$(curl -s -o state.json -w "%{http_code}" "$URL" || echo "000")
          echo "http=$CODE" >> "$GITHUB_OUTPUT"
          cat state.json || true

      - name: Decide action (robust summary parsing)
        id: decide
        run: |
          python - <<'PY'
          import json, os, re
          state = {}
          if os.path.exists("state.json"):
              state = json.load(open("state.json"))

          main_loaded = bool(state.get("main_loaded"))
          err  = (state.get("error_type") or "").strip()
          file = (state.get("file") or "").strip()
          line = str(state.get("line") or "0").strip()
          summary = (state.get("summary") or "").strip()

          # Se arquivo veio "<frozen ...>", extrai do summary o caminho real (/app/src/...)
          if (not file or file.startswith("<frozen")):
              m = re.search(r'File\s+"(?:/app/)?(src/[^"]+)",\s+line\s+(\d+)', summary)
              if m:
                  file = m.group(1)
                  line = m.group(2)

          if not line.isdigit():
              line = "0"

          has_indent = ("IndentationError" in err) or ("IndentationError" in summary)
          need_incident = (not main_loaded) and (has_indent or err or summary)

          open("decision.txt","w").write(json.dumps({
              "main_loaded": main_loaded,
              "error_type": err,
              "file": file,
              "line": line,
              "summary_head": summary[:200]
          }))

          if (not main_loaded) and has_indent and file and line.isdigit() and int(line) > 0:
              open("signal_autofix.txt","w").write(f"{file}\n{line}\n")

          if need_incident:
              open("signal_incident.txt","w").write("1\n")
          PY

          if [ -f signal_autofix.txt ]; then
            echo "autofix=true" >> "$GITHUB_OUTPUT"
          else
            echo "autofix=false" >> "$GITHUB_OUTPUT"
          fi
          if [ -f signal_incident.txt ]; then
            echo "incident=true" >> "$GITHUB_OUTPUT"
          else
            echo "incident=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Open incident (always when main failed)
        if: ${{ steps.decide.outputs.incident == 'true' }}
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "Auto-incident: Boot failure in production (see /ops/boot-state)"
          content-filepath: state.json
          labels: |
            auto/incident
            runtime

      - name: Ensure indent_fix.py
        if: ${{ steps.decide.outputs.autofix == 'true' }}
        run: |
          mkdir -p scripts/autofix
          cat > scripts/autofix/indent_fix.py <<'PY'
          #!/usr/bin/env python3
          import sys, pathlib
          if len(sys.argv) < 3:
              print("usage: indent_fix.py <file> <line>", file=sys.stderr); sys.exit(2)
          p = pathlib.Path(sys.argv[1])
          line_no = int(sys.argv[2])
          lines = p.read_text(encoding="utf-8", errors="ignore").splitlines()
          if not (1 <= line_no <= len(lines)): sys.exit(0)
          def ind(s): return len(s) - len(s.lstrip(" "))
          # alinha a linha alvo ao bloco pai (múltiplos de 4)
          idx = line_no - 1
          parent = idx - 1
          while parent >= 0:
              s = lines[parent].rstrip()
              if s.strip() and s.strip().endswith(":"):
                  break
              parent -= 1
          target = ind(lines[parent]) + 4 if parent >= 0 else 0
          lines[idx] = (" " * target) + lines[idx].lstrip(" ")
          p.write_text("\n".join(lines) + ("\n" if not lines[-1].endswith("\n") else ""), encoding="utf-8")
          print(f"fixed {p} at line {line_no} -> indent {target}")
          PY
          chmod +x scripts/autofix/indent_fix.py

      - name: Create branch & try indent autofix
        id: autofix
        if: ${{ steps.decide.outputs.autofix == 'true' }}
        run: |
          set -e
          FILE=$(head -n1 signal_autofix.txt)
          LINE=$(tail -n1 signal_autofix.txt)
          TS=$(date +%s)
          BRANCH="autofix/indent-$(echo "$FILE" | tr '/ ' '--')-$LINE-$TS"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
          git config user.name "ops-bot"
          git config user.email "ops-bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          python scripts/autofix/indent_fix.py "$FILE" "$LINE" || true
          # não versionar artefatos temporários do workflow
          rm -f decision.txt signal_autofix.txt signal_incident.txt state.json || true
          git add -A
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "no staged changes after indent fix"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            git commit -m "autofix: normalize indentation on ${FILE}:${LINE}"
            git push -u origin HEAD || true
          fi

      - name: ESCALATE — replace src/main.py with clean baseline
        id: escalate
        if: ${{ steps.autofix.outputs.changed == 'false' }}
        run: |
          set -e
          TS=$(date +%s)
          BRANCH="autofix/replace-main-with-clean-$TS"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
          git config user.name "ops-bot"
          git config user.email "ops-bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          # usa o script existente no repo para escrever um main.py limpo e funcional
          if [ -f fix_main_clean.py ]; then
            python fix_main_clean.py
          else
            echo "FATAL: fix_main_clean.py não encontrado"; exit 1
          fi
          git add -A
          git commit -m "autofix: replace src/main.py with clean baseline (fix_main_clean)"
          git push -u origin HEAD || true

      - name: Open PR for indent autofix (if changed)
        if: ${{ steps.autofix.outputs.changed == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_BRANCH: ${{ steps.autofix.outputs.branch_name }}
        run: |
          set -e
          echo "Opening PR from ${HEAD_BRANCH} to main"
          curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d @- <<EOF || true
          {
            "title": "Autofix: Indentation in production (via /ops/boot-state)",
            "head": "${HEAD_BRANCH}",
            "base": "main",
            "body": "Correção automática de indentação baseada no estado de boot em produção.",
            "maintainer_can_modify": true
          }
          EOF

      - name: Open PR for clean replace (if escalated)
        if: ${{ steps.autofix.outputs.changed == 'false' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_BRANCH: ${{ steps.escalate.outputs.branch_name }}
        run: |
          set -e
          echo "Opening PR from ${HEAD_BRANCH} to main (clean baseline)"
          curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d @- <<EOF || true
          {
            "title": "Autofix: Replace src/main.py with clean baseline (fix_main_clean)",
            "head": "${HEAD_BRANCH}",
            "base": "main",
            "body": "Substitui src/main.py pela versão limpa e funcional já validada em produção (fallback fix_main_clean).",
            "maintainer_can_modify": true
          }
          EOF

      - name: WhatsApp ping
        if: ${{ env.META_ACCESS_TOKEN != '' && env.WHATSAPP_PHONE_NUMBER_ID != '' && env.OPS_ALERT_PHONE != '' }}
        run: |
          HTTP="${{ steps.probe.outputs.http }}"
          HEAD=$(cat decision.txt 2>/dev/null || echo '{}')
          MSG="Ops Watcher (HTTP): http=${HTTP} head=${HEAD}"
          curl -s -X POST "https://graph.facebook.com/v21.0/${WHATSAPP_PHONE_NUMBER_ID}/messages" \
            -H "Authorization: Bearer ${META_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"messaging_product\":\"whatsapp\",\"to\":\"${OPS_ALERT_PHONE}\",\"type\":\"text\",\"text\":{\"preview_url\":false,\"body\":\"${MSG:0:900}\"}}" \
            >/dev/null 2>&1 || true
