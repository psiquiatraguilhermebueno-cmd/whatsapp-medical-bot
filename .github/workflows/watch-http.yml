name: watch-http

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

jobs:
  probe-and-autofix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    env:
      POST_DEPLOY_URL: ${{ secrets.POST_DEPLOY_URL }}
      META_ACCESS_TOKEN: ${{ secrets.META_ACCESS_TOKEN }}
      WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
      OPS_ALERT_PHONE: ${{ secrets.OPS_ALERT_PHONE }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Probe boot-state
        id: probe
        run: |
          set -e
          URL="${POST_DEPLOY_URL}/ops/boot-state"
          echo "GET $URL"
          CODE=$(curl -s -o state.json -w "%{http_code}" "$URL" || echo "000")
          echo "http=$CODE" >> "$GITHUB_OUTPUT"
          cat state.json || true

      - name: Decide action (robust summary parsing)
        id: decide
        run: |
          python - <<'PY'
          import json, os, re
          state = {}
          if os.path.exists("state.json"):
              state = json.load(open("state.json"))

          main_loaded = bool(state.get("main_loaded"))
          err  = (state.get("error_type") or "").strip()
          file = (state.get("file") or "").strip()
          line = str(state.get("line") or "0").strip()
          summary = (state.get("summary") or "").strip()

          # Se arquivo veio "<frozen ...>", extrai do summary o caminho real (/app/src/...)
          if (not file or file.startswith("<frozen")):
              m = re.search(r'File\s+"(?:/app/)?(src/[^"]+)",\s+line\s+(\d+)', summary)
              if m:
                  file = m.group(1)
                  line = m.group(2)

          if not line.isdigit():
              line = "0"

          has_indent = ("IndentationError" in err) or ("IndentationError" in summary)
          need_incident = (not main_loaded) and (has_indent or err or summary)

          open("decision.txt","w").write(json.dumps({
              "main_loaded": main_loaded,
              "error_type": err,
              "file": file,
              "line": line,
              "summary_head": summary[:200]
          }))

          if (not main_loaded) and has_indent and file and line.isdigit() and int(line) > 0:
              open("signal_autofix.txt","w").write(f"{file}\n{line}\n")

          if need_incident:
              open("signal_incident.txt","w").write("1\n")
          PY

          if [ -f signal_autofix.txt ]; then
            echo "autofix=true" >> "$GITHUB_OUTPUT"
          else
            echo "autofix=false" >> "$GITHUB_OUTPUT"
          fi
          if [ -f signal_incident.txt ]; then
            echo "incident=true" >> "$GITHUB_OUTPUT"
          else
            echo "incident=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Open incident (always when main failed)
        if: ${{ steps.decide.outputs.incident == 'true' }}
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "Auto-incident: Boot failure in production (see /ops/boot-state)"
          content-filepath: state.json
          labels: |
            auto/incident
            runtime

      - name: Ensure indent_fix.py
        if: ${{ steps.decide.outputs.autofix == 'true' }}
        run: |
          mkdir -p scripts/autofix
          cat > scripts/autofix/indent_fix.py <<'PY'
          #!/usr/bin/env python3
          import sys, pathlib
          if len(sys.argv) < 3:
              print("usage: indent_fix.py <file> <line>", file=sys.stderr); sys.exit(2)
          p = pathlib.Path(sys.argv[1])
          line_no = int(sys.argv[2])
          lines = p.read_text(encoding="utf-8", errors="ignore").splitlines()
          if not (1 <= line_no <= len(lines)): sys.exit(0)
          def ind(s): return len(s) - len(s.lstrip(" "))
          # alinha a linha alvo ao bloco pai (múltiplos de 4)
          idx = line_no - 1
          parent = idx - 1
          while parent >= 0:
              s = lines[parent].rstrip()
              if s.strip() and s.strip().endswith(":"):
                  break
              parent -= 1
          target = ind(lines[parent]) + 4 if parent >= 0 else 0
          lines[idx] = (" " * target) + lines[idx].lstrip(" ")
          p.write_text("\n".join(lines) + ("\n" if not lines[-1].endswith("\n") else ""), encoding="utf-8")
          print(f"fixed {p} at line {line_no} -> indent {target}")
          PY
          chmod +x scripts/autofix/indent_fix.py

      - name: Create branch & try indent autofix
        id: autofix
        if: ${{ steps.decide.outputs.autofix == 'true' }}
        run: |
          set -e
          FILE=$(head -n1 signal_autofix.txt)
          LINE=$(tail -n1 signal_autofix.txt)
          TS=$(date +%s)
          BRANCH="autofix/indent-$(echo "$FILE" | tr '/ ' '--')-$LINE-$TS"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
          git config user.name "ops-bot"
          git config user.email "ops-bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          python scripts/autofix/indent_fix.py "$FILE" "$LINE" || true
          # não versionar artefatos temporários do workflow
          rm -f decision.txt signal_autofix.txt signal_incident.txt state.json || true
          git add -A
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "no staged changes after indent fix"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            git commit -m "autofix: normalize indentation on ${FILE}:${LINE}"
            git push -u origin HEAD || true
          fi

      - name: ESCALATE — replace src/main.py with clean baseline (no Flask needed)
        id: escalate
        if: ${{ steps.autofix.outputs.changed == 'false' }}
        run: |
          set -e
          TS=$(date +%s)
          BRANCH="autofix/replace-main-with-clean-$TS"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
          git config user.name "ops-bot"
          git config user.email "ops-bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          mkdir -p src
          cat > src/main.py <<'PY'
import os
import sys
import logging

# DON'T CHANGE THIS !!!
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, send_from_directory, jsonify, request
from flask_cors import CORS
from datetime import datetime

# Extensões e blueprints do projeto
from src.models.user import db
from src.routes.user import user_bp
from src.routes.patient import patient_bp
from src.routes.reminder import reminder_bp
from src.routes.response import response_bp
from src.routes.scale import scale_bp
from src.routes.whatsapp import whatsapp_bp
from src.routes.telegram import telegram_bp
from src.routes.medication import medication_bp
from src.routes.mood import mood_bp
from src.routes.scheduler import scheduler_bp
from src.routes.iclinic import iclinic_bp
from src.routes.admin_tasks import admin_tasks_bp
from src.routes.admin_patient import admin_patient_bp
from src.admin.routes import admin_bp
from src.admin.services.scheduler_service import init_campaign_scheduler
from src.jobs.uetg_scheduler import init_scheduler

# Logging básico
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(name)s: %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__, static_folder=os.path.join(os.path.dirname(__file__), "static"))
app.config["SECRET_KEY"] = os.getenv("APP_SECRET", "change-me")

# Banco de dados
database_url = os.getenv('DATABASE_URL')
if database_url and database_url.startswith("postgres://"):
    database_url = database_url.replace("postgres://", "postgresql://", 1)
app.config['SQLALCHEMY_DATABASE_URI'] = database_url or f"sqlite:///{os.path.join(os.path.dirname(__file__), 'app.db')}"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Inicializações
CORS(app)
db.init_app(app)

# Blueprints
app.register_blueprint(user_bp, url_prefix="/api/users")
app.register_blueprint(patient_bp, url_prefix="/api/patients")
app.register_blueprint(reminder_bp, url_prefix="/api/reminders")
app.register_blueprint(response_bp, url_prefix="/api/responses")
app.register_blueprint(scale_bp, url_prefix="/api/scales")
app.register_blueprint(whatsapp_bp, url_prefix="/api/whatsapp")
app.register_blueprint(telegram_bp, url_prefix="/api/telegram")
app.register_blueprint(medication_bp, url_prefix="/api/medications")
app.register_blueprint(mood_bp, url_prefix="/api/moods")
app.register_blueprint(scheduler_bp, url_prefix="/api/scheduler")
app.register_blueprint(iclinic_bp, url_prefix="/api/iclinic")
app.register_blueprint(admin_tasks_bp, url_prefix="/admin/api")
app.register_blueprint(admin_patient_bp, url_prefix="/admin/api")
app.register_blueprint(admin_bp, url_prefix="/admin")

@app.route("/")
def index():
    return jsonify({
        "service": "whatsapp-medical-bot",
        "status": "running",
        "version": "1.0.0",
        "admin_url": "/admin"
    })

@app.route("/health")
def health():
    try:
        with app.app_context():
            conn = db.engine.connect()
            conn.execute(db.text("SELECT 1"))
            conn.close()
        db_status = "connected"
    except Exception as e:
        logger.exception("DB health check failed")
        db_status = f"error: {e.__class__.__name__}"

    return jsonify({
        "service": "whatsapp-medical-bot",
        "status": "healthy",
        "version": "1.0.0",
        "database": db_status,
        "admin_enabled": True
    })

@app.route("/static/<path:filename>")
def static_files(filename):
    return send_from_directory(app.static_folder, filename)

if __name__ == "__main__":
    with app.app_context():
        try:
            db.create_all()
            logger.info("✅ Database tables created/verified")
        except Exception as e:
            logger.exception("⚠️ Error creating tables")

        # u-ETG scheduler
        try:
            init_scheduler()
            logger.info("✅ u-ETG Scheduler initialized")
        except Exception as e:
            logger.exception("⚠️ Error initializing u-ETG scheduler")

        # Campaign scheduler
        try:
            init_campaign_scheduler()
            logger.info("✅ Campaign Scheduler initialized")
        except Exception as e:
            logger.warning(f"Campaign scheduler disabled: {e}")

    port = int(os.getenv("PORT", 8080))
    debug = os.getenv("FLASK_ENV") == "development"
    logger.info(f"Starting on port {port} (debug={debug})")
    app.run(host="0.0.0.0", port=port, debug=debug)
PY
          git add -A
          git commit -m "autofix: replace src/main.py with clean baseline (no-runner-deps)"
          git push -u origin HEAD || true

      - name: Open PR for indent autofix (if changed)
        if: ${{ steps.autofix.outputs.changed == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_BRANCH: ${{ steps.autofix.outputs.branch_name }}
        run: |
          set -e
          echo "Opening PR from ${HEAD_BRANCH} to main"
          curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d @- <<EOF || true
          {
            "title": "Autofix: Indentation in production (via /ops/boot-state)",
            "head": "${HEAD_BRANCH}",
            "base": "main",
            "body": "Correção automática de indentação baseada no estado de boot em produção.",
            "maintainer_can_modify": true
          }
          EOF

      - name: Open PR for clean replace (if escalated)
        if: ${{ steps.autofix.outputs.changed == 'false' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_BRANCH: ${{ steps.escalate.outputs.branch_name }}
        run: |
          set -e
          echo "Opening PR from ${HEAD_BRANCH} to main (clean baseline)"
          curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d @- <<EOF || true
          {
            "title": "Autofix: Replace src/main.py with clean baseline",
            "head": "${HEAD_BRANCH}",
            "base": "main",
            "body": "Substitui src/main.py pela versão limpa e funcional validada (equivalente ao fallback em produção).",
            "maintainer_can_modify": true
          }
          EOF

      - name: WhatsApp ping
        if: ${{ env.META_ACCESS_TOKEN != '' && env.WHATSAPP_PHONE_NUMBER_ID != '' && env.OPS_ALERT_PHONE != '' }}
        run: |
          HTTP="${{ steps.probe.outputs.http }}"
          HEAD=$(cat decision.txt 2>/dev/null || echo '{}')
          MSG="Ops Watcher (HTTP): http=${HTTP} head=${HEAD}"
          curl -s -X POST "https://graph.facebook.com/v21.0/${WHATSAPP_PHONE_NUMBER_ID}/messages" \
            -H "Authorization: Bearer ${META_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"messaging_product\":\"whatsapp\",\"to\":\"${OPS_ALERT_PHONE}\",\"type\":\"text\",\"text\":{\"preview_url\":false,\"body\":\"${MSG:0:900}\"}}" \
            >/dev/null 2>&1 || true
